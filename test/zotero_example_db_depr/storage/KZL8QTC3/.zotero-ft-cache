Breaking Good: Fracture Modes for Realtime Destruction

SILVIA SELL√ÅN, University of Toronto

JACK LUONG, California State University, Fresno and University of California, Los Angeles

LETICIA MATTOS DA SILVA, University of California, Los Angeles and Massachusetts Institute of Technology

ARAVIND RAMAKRISHNAN, University of Maryland and University of Toronto

YUCHUAN YANG, University of California, Los Angeles

ALEC JACOBSON, University of Toronto and Adobe Research

0m2s

Vibration modes = a shape‚Äôs natural deformation patterns

Our Fracture modes = a shape‚Äôs natural breaking patterns

Fig. 1. Drawing an analogy with the well-studied vibration modes, we define a shape‚Äôs fracture modes, which we can precompute for realtime applications.

Drawing a direct analogy with the well-studied vibration or elastic modes, we introduce an object‚Äôs fracture modes, which constitute its preferred or most natural ways of breaking. We formulate a sparsified eigenvalue problem, which we solve iteratively to obtain the ùëõ lowest-energy modes. These can be precomputed for a given shape to obtain a prefracture pattern that can substitute the state of the art for realtime applications at no runtime cost but significantly greater realism. Furthermore, any realtime impact can be projected onto our modes to obtain impact-dependent fracture patterns without the need for any online crack propagation simulation. We not only introduce this theoretically novel concept, but also show its fundamental and practical advantages in a diverse set of examples and contexts.
CCS Concepts: ‚Ä¢ Computing methodologies ‚Üí Physical simulation.
Additional Key Words and Phrases: fracture simulation, modal analysis.
ACM Reference Format: Silvia Sell√°n, Jack Luong, Leticia Mattos Da Silva, Aravind Ramakrishnan, Yuchuan Yang, and Alec Jacobson. 2022. Breaking Good: Fracture Modes for Realtime Destruction. ACM Trans. Graph. 1, 1, Article 1 (January 2022), 12 pages. https://doi.org/10.1145/3549540
1 INTRODUCTION
The patterns and fragmentations formed by an object undergoing brittle fracture add richness and realism to destructive simulations. Unfortunately, existing methods for producing the most high-quality realistic fractures (e.g., for the film industry) require hefty simulations too expensive for many realtime applications. An attractive

and popular alternative is to rely on precomputed fragmentation patterns at the modeling stage that can be swapped in at run-time when an impact is detected. Existing prefracture methods use geometric heuristics that can produce unrealistic patterns oblivious of an object‚Äôs elastic response profile or structural weaknesses (see Figs. 2, 3 and 6). Geometric patterns alone also do not answer which fragments should break-off for a given impact at run-time, inviting difficult to tune heuristics or complete fracture regardless of impact. As a result, these procedural methods find use when fractures are in the background or obscured by particle effects; elsewhere, video game studios may rely on artist-authored fragmentation patterns.
In this paper, we present a method for prefracturing stiff brittle materials which draws a direct analogy to a solid shape‚Äôs elastic vibration modes. We compute a shape‚Äôs fracture modes1, which algebraically span the shape‚Äôs natural ways of breaking apart. By introducing a continuity objective under a sparsity-inducing norm to the classic vibration modes optimization problem, we identify unique and orthogonal modes of fracture in increasing order of a generalized notion of frequency.
1Not to be confused with the ‚Äúthree modes of fracture‚Äù [Irwin 1957].

Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org.
¬© 2022 Association for Computing Machinery. 0730-0301/2022/1-ART1 $15.00 https://doi.org/10.1145/3549540

Fig. 2. Popular Voronoi-based prefracturing results in recognizable, unrealistic shapes. Our fracture modes break across weak regions.

ACM Trans. Graph., Vol. 1, No. 1, Article 1. Publication date: January 2022.

1:2 ‚Ä¢ Silvia Sell√°n, Jack Luong, Leticia Mattos Da Silva, Aravind Ramakrishnan, Yuchuan Yang, and Alec Jacobson

0m48s

2m25s

Clear weakness

Input

Random Voronoi fractures

Our 1st fracture mode

Fig. 3. Existing procedural prefracture algorithms (center) rely on random-

ness and do not account for the geometrically weak regions of an object,

unlike our proposed fracture modes (right).

The first ùëò fracture modes can be intersected against each other to define a prefracture pattern as a drop-in replacement to existing procedural methods (see Fig. 2). Furthermore, impacts determined at runtime can be efficiently projected onto the linear space of precomputed fracture modes to obtain impact-dependent fracture without the need for costly stress computation or crack propagation.
We demonstrate the theoretical and practical advantages and limitations of our algorithm over existing procedural methods and evaluate its accuracy by qualitatively comparing to existing works in worst-case structural analysis. We showcase the benefits of our algorithm within an off-the-shelf rigid body simulator to produce animations on a diverse set of shapes and impacts. We show the realtime potential of fracture modes with a prototypical interactive 2D application (see Fig. 4 and accompanying video).

2 RELATED WORK
Fracture simulation has an extensive body of previous work; Muguercia et al. [2014] provide a thorough survey. Stiff brittle fracture is characterized when little or no perceptible deformation occurs before fracture (i.e., when the object is otherwise rigid). Modeling the dynamic or quasistatic growth of brittle fracture patterns in a high performant way requires not just high spatial resolution but also high temporal resolution at the microsecond scale [Kirugulige et al. 2007], modeling stress concentration and subsequent release. This process has been approximated, for example, using mass-springs [Hirota et al. 1998; Norton et al. 1991], finite elements [Kaufmann et al. 2009; Koschier et al. 2015; O‚ÄôBrien and Hodgins 1999; Pfaff et al. 2014; Wicke et al. 2010], boundary elements [Hahn and Wojtan 2015, 2016; Zhu et al. 2015], and the material-point method [Fan et al. 2022; Wolper et al. 2020, 2019]. While any such method can eventually meet realtime demands by lowering the discretization fidelity (e.g., on low-res cage geometry [Muller et al. 2004; Parker and O‚ÄôBrien 2009] or a modal subspace [Glondu et al. 2012]) or assuming large enough computational resources, we instead focus our attention to previous methods which achieve realtime performance via the well established workflow of prefracturing. This workflow sidesteps computationally expensive and numerically fragile remeshing operations. It fits tidily into the existing realtime graphics pipeline, where geometric resolutions and computational resources can be preallocated to ensure low latency and consistent performance.

ACM Trans. Graph., Vol. 1, No. 1, Article 1. Publication date: January 2022.

Fig. 4. Screenshots of our 2D interactive prototype, in which the user can
select the impact position to obtain different breaking patterns.
Creating prefracture patterns manually requires skill and time, precluding fully automatic pipelines. Many commercial packages (e.g., Unreal Engine, Houdini) implement or suggest geometric prefracturing heuristics to segment a shape into solid subfragments. Voronoi diagrams of randomly scattered points [Oh et al. 2012; Raghavachary 2002] capture the stochastic quality of fracture, but result in overly regular and convex fragments with perfectly flat sides. Despite lacking realism, convexity can be advantageous for simulations. For example, it enables realtime collision detection and even offline at massive scales [Zafar et al. 2010]. Beyond collision detection, approximate convex decomposition has been employed as a prefracturing technique, allowing fracture patterns to be applied locally at low cost [M√ºller et al. 2013]. M√ºller et al. [2013] rely on manual intervention at multiple stages, making it not comparable as an automatic method; however, we compare to the Voronoi decomposition it is based on in Figs. 2 and 3.
Schvartzman and Otaduy [2014] increase the space of possible fragments beyond convexity by computing the Voronoi decomposition on a higher dimensional embedding. The regularity of these fragments can be augmented further by randomly generated ‚Äúcutter‚Äù objects (i.e., bumpy planes slicing though the input shape) or perturbed level set functions (see, e.g., [Museth et al. 2021]). These stochastic methods often miss obvious structural weaknesses (see Fig. 3) or result in implausible fragments (see Fig. 6). While the defects of these methods can be resolved manually, hidden behind destruction dust or obscured by fast explosions, our fracture modes consistently produce non-convex fragments whose boundaries originate from minimal stress displacements of the shape. Beyond taking into account the physical elastic behavior of the geometry, our method can incorporate constraints to avoid fractures in certain areas. While our fracture modes are slower to compute than geometriconly procedural prefracture, this cost is added only at the offline precomputation stage.
Given a precomputed fracture pattern, one must decide which fractures are activated when the object receives a given online impact. Strategies range from simple heuristics like Euclidean distance thresholds and centering a spatial fracture pattern on the contact point [M√ºller et al. 2013; Su et al. 2009] to learning from examples [Schvartzman and Otaduy 2014]. A key practical contribution of our fracture modes is that they span a linear subspace onto which impacts can be cheaply projected to trigger fragment displacements at runtime, removing the need for heuristics or data-based approaches.

Worst-case analysis and experiments First two fracture modes

Breaking Good: Fracture Modes for Realtime Destruction ‚Ä¢ 1:3

[Zhou et al. 2013]

Ours

Fig. 5. Zhou et al. [2013] (left) identify the geometrically weakest regions of a given shape, which align with their real-world experiments (center). Our fracture modes (right) produce fracture patterns qualitatively similar.

2.1 Sparsified eigenproblems

Our approach for defining fracture modes lies within a broader class of optimization problems of the form:

argmin
X‚ä§ MX=I

1 trace
2

X‚ä§LX

ùëò
+ ùëî(Xùëñ ) ,
ùëñ =1

(1)

where Xùëñ as the ùëñth column of X ‚àà Rùëõ√óùëò is referred to as a modal vector or mode, M and L are positive semi-definite ùëõ√óùëõ matrices, and

ùëî : Rùëõ ‚Üí R is a sparsity-inducing norm, like ùëî(x) = ‚à•x‚à•1. When
ùëî 0, this reduces to the generalized eigenvalue problem (see e.g.,
[Bai et al. 2000] Chaps. 4-5), whose solution satisfies LX = MXŒõ,
where the diagonal ùëò√óùëò matrix Œõ contains the ùëò smallest eigenvalues (Œõùëñ,ùëñ = Xùëñ‚ä§LXùëñ ). For non-trivial ùëî, we may continue to consider ùúÜùëñ = Xùëñ‚ä§ùêøXùëñ + ùëî(Xùëñ ) as describing the frequency of the ùëñth mode.
Ozolins et al. [2013] proposed the notion of compressed modes

using a sparsity-inducing ‚Ñì1-norm to compute localized (sparse) solutions to Schr√∂dinger‚Äôs equation. Neumann et al. [2014] extended this

idea to compressed eigenfunctions of the Laplace-Beltrami operator

on 3D surfaces, advocating for an alternating direction method of

multipliers (ADMM) optimization method. While ADMM‚Äôs standard

convergence guarantees [Boyd 2010] do not apply to non-convex

problem such as Eq. (1), Neumann et al. [2014] demonstrate success-

ful local convergence albeit with dependency on the initial guess and optimization path. Replacing the X‚ä§LX term with a data-term,

Neumann et al. [2013] use a similar ADMM approach to create sparse

PCA bases for mesh deformations.

Brandt and Hildebrandt [2017] further extend this line of smooth,

sparse modal decompositions by considering ùêø to be the Hessian of

an elastic energy. They propose an iterative mode-by-mode optimiza-

tion. The current mode is optimized by sub-iterations consisting of

a quadratic program solve resulting from linearizing the constraints

around the current iterant interleaved with normalization in order

Input openVDB fracture

Our Ô¨Årst three fracture modes

Fig. 6. Level-set methods (e.g., OpenVDB [Museth et al. 2021]) will produce non-convex, yet implausible fracture patterns unrelated to the structural integrity of the shape.

to approach a unit-norm vector. Despite the conspicuous downside that any sub-optimality of earlier modes is locked in possibly affecting the accuracy of later modes, this method enjoys performance and robustness improvements over the ADMM approach of Neumann et al. [2014]. Therefore, we follow suit with a similarly mode-bymode fixed-point iteration approach. Unique to our method is that we do not consider the sparsity of the modal vector itself, but rather the sparsity of the mode‚Äôs continuity over the domain.

3 FRACTURE MODES

Given an elastic solid object Œ© ‚äÇ Rùëë and a deformation map ùë¢ : Œ© ‚Üí Rùëë , we can formulate the object‚Äôs total strain energy as

‚à´

ùê∏Œ® (ùë¢) = Œ®(ùë¢, ùë•)ùëëùë•,

(2)

Œ©

where Œ® is the strain energy density function evaluated at points

ùë• ‚àà Œ© in the undeformed object.

Suppose we allow the deformation map ùë¢ to fracture the object Œ© into two disjoint pieces Œ©1 and Œ©2 along a given (ùëë ‚àí 1)-dimensional fracture fault ùëÜ (see

Œ©

S x

inset). Effectively, we‚Äôre allowing ùë¢ to be discontinuous at ùëÜ. Consider ùë•1 and ùë•2 to be the undeformed positions of points

u (x2) u(x1) D

infinitesimally on either side of a point

ùë• ‚àà ùëÜ on the fracture fault. Then, the difference between ùë¢ (ùë•1) and ùë¢ (ùë•2) describes the pointwise vector-valued discontinuity at ùë• ‚àà ùëÜ:

ùê∑ (ùë¢, ùë•

‚àà

ùëÜ)

=

ùë¢ (ùë•1)

‚àí ùë¢ (ùë•2)

‚àà

ùëë
R,

(3)

where ùê∑ = 0 would indicate continuity or absence of fracture. We can then compute the discontinuity energy associated with ùëÜ as

‚à´

‚à•ùê∑ (ùë¢, ùë•) ‚à•2ùëëùë• ,

(4)

ùë• ‚ààùëÜ

which can be seen as a cohesive surface energy from the FEM crack propagation literature (e.g., [Ortiz and Pandolfi 1999]). Unlike similar

cohesive energies found in graphics (e.g., for UV mapping [Poranne

et al. 2017] or shape interpolation [Zhu et al. 2017]), assuming small

displacements affords us this simpler, first-order approximation.

We now consider that the set of admissible discontinuities is not

just a single fracture fault, but a finite number of fault patches:
ùëÜ = {ùëÜ1, . . . , ùëÜùëù }. We assume that ùëÜ comes from a, for now, arbitrary over-segmentation of Œ©. This could be created with a high-resolution Voronoi diagram, by intersecting Œ© with random surfaces, voxel

boundaries, or by some a priori distribution of granular subobjects.

ACM Trans. Graph., Vol. 1, No. 1, Article 1. Publication date: January 2022.

1:4 ‚Ä¢ Silvia Sell√°n, Jack Luong, Leticia Mattos Da Silva, Aravind Ramakrishnan, Yuchuan Yang, and Alec Jacobson

Our fracture modes

Impact-dependent fracture

1m50s

Fig. 7. The same prefractured modes can be used to simulate many different impacts; for example, a racing simulator may destroy the player‚Äôs spaceship

differently depending on its impact.

œÜ

i

We define the total discontinuity energy associated with ùë¢ as

Hat functions are by construction contin-

ùëù‚à´

ùê∏ùê∑ (ùë¢) = ‚à•ùê∑ (ùë¢, ùëÜ) ‚à•2,1

‚à•ùê∑ (ùë¢, ùë•) ‚à•2ùëëùë• .

(5)

ùëñ=1 ùëÜùëñ

We add this to the strain energy to form the total energy:

ùê∏ (ùë¢) = ùê∏Œ® (ùë¢) + ùúî ùê∏ùê∑ (ùë¢),

(6)

where ùúî ‚àà R is a positive weight balancing the two terms. In the cohesive FEM context, ùúî can be understood as the square root of the
traction-displacement coefficient in the first fracture phase [Chowd-
hury and Narasimhan 2000]. Minimizing the ‚Ñì2,1 norm on the matrix ùê∑ is tantamount to minimizing the sparsity-inducing [Candes and
Wakin 2008] ‚Ñì1 norm on the lengths of each row. Minimizing the ‚Ñì1 norm ( ùëñ ùëó |ùê∑ùëñ ùëó |) directly would also lead to sparsity, but the solution would be rotationally dependent.
We can now define the ùëò lowest energy fracture modes as the set
of mass-orthonormal deformation maps {ùë¢ùëñ }ùëòùëñ=1 that minimize their combined total energy; i.e.,

uous. Normally, this is a good thing, but we

would like to have functions with arbitrarily

i

large co-dimension one patches of discon-

tinuities. Let us introduce the concept of an

œÜ

exploded mesh Œ©Àú , with the same ùëö faces as

f3

Œ© and same carrying geometry, but where each vertex is effectively repeated for each

1

3

f

2

incident triangle. Thus, Œ©Àú is composed of

ùëö combinatorially disconnected triangles and 3ùëö vertices ùë£ùëê ùëì with

ùëê = 1, 2, 3 and ùëì = 1, . . . , ùëö.

Hat functions ùúëÀú : Œ©Àú ‚Üí R defined on Œ©Àú reduce to barycentric coor-

dinate functions extended with zero value outside the corresponding

triangle (see inset). These trivially span the space of piecewise linear scalar discontinuous functions ùë¢ via vectors u ‚àà R3ùëö:

ùëö3

ùë¢ (ùë•) =

uùëê ùëì ùúëÀúùëê ùëì (ùë•).

(9)

ùëì =1 ùëê=1

ùëò
{ùë¢ùëñ }ùëòùëñ=1 = argmin ùê∏ (ùë¢ùëñ ) ,
{ùë¢ùëñ }ùëòùëñ=1 ùëñ=1

‚à´

s.t.

(ùë¢ùëñ )‚ä§ùúåùë¢ ùëóùëëùë•

=

ùëñ,ùëó
ùõø,

(7)

Œ©

where ùúå is the local mass density and ùõøùëñ,ùëó is the Kronecker delta. In general, for large enough ùúî, minimizers ùë¢ùëñ will have exactly zero ùê∏ùê∑ on all but a sparse subset of fault patches in ùëÜ, agreeing with the usual sparse coding theory [Candes and Wakin 2008].

3.1 Fracture Modes on Meshes

We will use this basis for each coordinate of our vector-valued deformation map, captured in a vector of coefficients u ‚àà R(ùëë+1)ùëöùëë , with the displacement at vertex ùëê of face ùëì selected by uùëê ùëì ‚àà Rùëë .
We may now discretize both terms in our energy in Eq. (6). First, the integral strain energy follows the usual FEM discretization as a sum over each element.

ùëö‚à´

ùê∏Œ® (u) =

Œ®(ùë¢, ùë•)ùëëùë• .

(10)

ùëì =1 ùëì

We will derive a discrete formulation of the variational problem in

Eq. (7) for a 2D solid object, represented as a triangle mesh Œ© with ùëõ

vertices and ùëö faces. In this construction, the mesh‚Äôs ùëù interior edges

will correspond to admissible fracture faults ùëÜ1, ¬∑ ¬∑ ¬∑ , ùëÜùëù . Everything that follows is straightforward to extend to 3D solids by exchanging

triangles and interior edges for tetrahedra and interior faces.

A traditional piecewise-linear finite element method (FEM) would

discretize the strain energy ùê∏Œ® using hat functions ùúëùëñ : Œ© ‚Üí R, ‚àÄùëñ = 1, . . . , ùëõ and associate a scalar function ùë¢ : Œ© ‚Üí R with a
vector u ‚àà Rùëõ such that

ùëõ

ùë¢ (ùë•) = uùëñùúëùëñ (ùë•).

(8)

ùëñ =1

We can abstract the choice of Œ® for now by considering small dis-
placements around the rest configuration such that it can be approximated by its Hessian matrix Q ‚àà R(ùëë+1)ùëöùëë√ó(ùëë+1)ùëöùëë :

ùê∏Œ® (u)

‚âà

1 u‚ä§Qu . 2

(11)

In Section 3.7 we discuss a further approximation specific to our model. Our basis functions ùúëÀú will only allow fractures along the mesh‚Äôs interior edges, therefore, the integral in Eq. (5) breaks into a contribution from each interior edge ùëí:

‚à´

ùê∏ùëí (ùë¢) = ‚à•ùê∑ (ùë¢, ùë•) ‚à•2ùëëùë• ,

(12)

ùëí

Vector-valued ùë¢ : Œ© ‚Üí Rùëë such as a deformation would be described coordinate-wise in the same way, via a vector u ‚àà Rùëëùëõ.

which we can compute exactly by two-point Gaussian quadrature (the integrand is a second-order polynomial).

ACM Trans. Graph., Vol. 1, No. 1, Article 1. Publication date: January 2022.

First fracture mode computed with‚Ä¶

Breaking Good: Fracture Modes for Realtime Destruction ‚Ä¢ 1:5

Input

Impact w

Projection w‚òÖ

‚Ä¶[Brandt and Hildebrandt 2017]‚Äôs random intialized ICCM

‚Ä¶our adapted ICCM

Fig. 8. We adapt the algorithm suggested by Brandt and Hildebrandt [2017] to use the eigenmodes of Q as initial guesses as opposed to random vectors.

For a given edge ùëí with length ùëô, corresponding to vertex pairs {ùëéùëì , ùëè ùëì } and {ùëêùëî, ùëëùëî} (see inset), this amounts to

ùê∏ùëí (u) =

ùëô 2

d ‚àö+1

2
+

d

‚àö‚àí1

2

32

32

cg

g

af d

f

bf dg

where

d (ùë° )

=

1+ùë° 2

( uùëé ùëì

‚àí uùëêùëî)

+

1

‚àí 2

ùë°

(uùëè

ùëì

‚àí uùëëùëî)

(13)

measures the pointwise discontinuity for the quadrature at para-

metric location ùë° ‚àà [‚àí1, 1] along the edge.

The full discontinuity energy associated with the map ùë¢ (ùë•) is

given by summing over every interior edge

ùëù

ùê∏ùê∑ (u) = ùê∏ùëí (u) .

(14)

ùëí =1

Finally, we can define the ùëò lowest-energy discrete fracture modes as column vectors of a matrix U ‚àà R(ùëë+1)ùëöùëë√óùëò satisfying

argmin
U‚ä§MÀú U=I

1 trace
2

U‚ä§QU

ùëò
+ ùúî (ùê∏ùê∑ (Uùëñ )) ,
ùëñ =1

(15)

where MÀú is the possibly lumped FEM mass matrix defined on the exploded mesh Œ©Àú .

3.2 Optimization

The definition of fracture modes on meshes involves solving the

optimization problem in Eq. (15). While the objective term is con-

vex, the orthogonality constraints are not. To proceed, we adapt the Iterated Convexification for Compressed Modes (ICCM) scheme

proposed by Brandt and Hildebrandt [2017]. ICCM computes the modes sequentially, assuming the first ùëñ ‚àí 1 columns of U have been

computed. In the original ICCM formulation, the process for finding the ùëñth column, Uùëñ proceeds by choosing a random unit-norm vector
c, then repeatedly solving

Uùëñ

‚Üê argmin
u

1 u‚ä§Qu + 2

ùúî

ùê∏ùê∑ (u)

(16)

Ô£Æ Ô£Ø

U‚ä§1

Ô£π Ô£∫

Ô£Æ0Ô£π Ô£ØÔ£∫

Ô£Ø.Ô£∫

Ô£Ø.Ô£∫

Ô£Ø.Ô£∫

Ô£Ø.Ô£∫

subject to Ô£Ø . Ô£∫ MÀú u = Ô£Ø . Ô£∫

(17)

Ô£ØÔ£ØÔ£ØUùëñ‚ä§‚àí1Ô£∫Ô£∫Ô£∫

Ô£ØÔ£∫ Ô£Ø0Ô£∫ Ô£ØÔ£∫

Ô£Ø Ô£Ø

c‚ä§

Ô£∫ Ô£∫

Ô£ØÔ£Ø1Ô£∫Ô£∫

Ô£∞Ô£ª

Ô£∞Ô£ª

and updating

c‚Üê

Uùëñ ,

(18)

U‚ä§
ùëñ

MÀú Uùëñ

Runtime
Fig. 9. We propagate any impact (left) using an elastic shockwave (middle). We then project this propagated impact onto our modes (right). At runtime (see text), we compute w‚òÖ directly without the need for linear solves.

Larger œÉ Fig. 10. A larger threshold (smaller impact) produces less fracture pieces.

until convergence is detected by ‚à•Uùëñ ‚àí c‚à• falling below some tolerance ùúÄ. By linearizing the (quadratic) norm constraint, the minimization problem Eq. (16) becomes a convex conic problem that we solve with off-the-shelf techniques (see Appendix A).
We found that random initializations for c not only introduce non-determinism, but can also sometimes result in a large number of inner iterations and sub-optimal local minima (see Fig. 8). Instead, when computing Uùëñ we initialize c with the ùëñth continuous eigenvectors of Q (defined on the unexploded mesh). We compute these ùëò initial vectors at once using the SciPy wrapper for the sparse eigen solver Arpack [Lehoucq et al. 1998]. We outline our complete fracture mode computation algorithm in Algorithm 1.

3.3 Impact-dependent fracture
By construction, the columns of U form an orthonormal basis of the lowest-energy ùëò-dimensional subspace of possible fractures of Œ©. This key feature means we can precompute an object‚Äôs fracture modes right after its design. Then, inside an interactive application we can project any detected impact onto our modes to obtain impactdependent realtime fracture (see Fig. 9).
If a collision is detected between Œ© and another object, with contact point ùëù and normal ùëõ√¨, we can define the exploded-vertex-wise impact vector w ‚àà R(ùëë+1)ùëöùëë . Ideally, w would be the displacements determined by an extremely short-time-duration simulation of elastic shock propagation. In lieu of being able to compute this in realtime, we use an approximation based on distance to smear the impact into the object:

wùëê ùëì = ùëî(ùëù, ùë£ùëê ùëì ) ùëõ√¨ , ‚àÄùëê = 1, 2, 3 , ùëì = 1, . . . , ùëö

(19)

where ùëî is a filter that vanishes as ùë£ùëê ùëì is far from ùëù. Then, we project w onto our modes to obtain our projected impact

ùëò

ùëò

w‚òÖ = Uùëñ Uùëñ‚ä§MÀú w = Uùëñ Uùëñ‚ä§MÀú gùëõ√¨ .

(20)

ùëñ =1

ùëñ =1

An immediate choice of ùëî would be a Gaussian density function centered at ùëù. A more physically based choice of ùëî can be obtained through a single implicit timestep of an elastic shockwave equation

g = MÀú ‚àí ùúèLÀú ‚àí1 MÀú ùõøùëù ,

(21)

ACM Trans. Graph., Vol. 1, No. 1, Article 1. Publication date: January 2022.

1:6 ‚Ä¢ Silvia Sell√°n, Jack Luong, Leticia Mattos Da Silva, Aravind Ramakrishnan, Yuchuan Yang, and Alec Jacobson

Algorithm 1: Fracture Modes via Adapted ICCM
Let Q be a PSD matrix, ùëò ‚àà N C ‚Üê eigenvectors(Q, M, ùëò) for ùëñ = 1, . . . , ùëò do
c ‚Üê Cùëñ repeat
Uùëñ ‚Üê solve Eq. (16) (see Appendix A)
c ‚Üê Uùëñ / Uùëñ‚ä§MÀú Uùëñ until ‚à•Uùëñ ‚àí c‚à• ‚â§ ùúÄ return U

where ùúè is the timestep of the simulation our fractures are embedded in. This choice of ùëî has benefits beyond physical inspiration, by ensuring an impact is only blurred onto regions that are geodesically close to one another, regardless of whether they are Euclideanly close (see Fig. 9). However, computing this g upon impact would involve solving a linear system at runtime. We avoid this by precomputing

Aùëñ = Uùëñ‚ä§MÀú MÀú ‚àí ùúèLÀú ‚àí1 MÀú ,

(22)

thus requiring only a matrix multiplication at runtime:

ùëò

w‚òÖ = Uùëñ Aùëñùõøùëùùëõ√¨ .

(23)

ùëñ =1

Let Œ©Àú w‚òÖ be the exploded mesh Œ©Àú as deformed by the map ùë§‚òÖ. For any two vertices ùë£ùëéùëì , ùë£ùëêùëî that are coincident in Œ©Àú (i.e., that came from the same original vertex in Œ©), we will glue (i.e., un-explode)

them if their deformation maps differ by less than some tolerance,

‚à•w‚òÖ
ùëéùëì

‚àí wùëê‚òÖùëî ‚à•

<

ùúé. This results in a new fractured

mesh

Œ©‚òÖ, whose

fracture pattern depends meaningfully on the nature of the impact

and which we can output to the simulation.

Our single timestep in Eq. (21) is an approximation that makes

w‚òÖ depend linearly on the impact. This has the added effect that

scaling ùúé and scaling the magnitude of the impact are equivalent

in our model. Thus, ùúé could be linked to the force of the impact or

the relative speed if one has access to this dynamic information (see

Fig. 10). We note that this equivalence is a product of our modeling

choices and may not always yield physically accurate results. For

example, a large force on a small area may cause immediate local

fractures, quickly reducing the stress before it propagates further; in

our model, the same impact would likely cause large global fractures.

3.4 Efficient implementation for real-time fracture
In 3D, our fracture mode computation needs a tetrahedralization of the input‚Äôs interior, but practical realtime applications prefer to work with triangle surface meshes for input and output. Fortunately, the sparsity inducing discontinuity norm results in fracture modes which are continuous across most pairs of neighboring tetrahedra. It is unnecessary to keep the entire tetrahedral mesh at runtime. Instead, we can determine the connected components determined by neighboring tetrahedra whose shared face‚Äôs discontinuity term is below ùúé across all ùëò modes (or below the lowest possible ùúé allowed by the dynamic system). The boundary of each component is a solid

ACM Trans. Graph., Vol. 1, No. 1, Article 1. Publication date: January 2022.

Algorithm 2: Simple nested cages via binary search
Let ùëâin, ùêπin be the vertex and face lists of the input mesh, and ùëötarget the desired number of output faces. Binary Search on offset amount ùëë
ùëâmc,ùêπmc ‚Üê marching-cubes( distance to ùëâin,ùêπin minus ùëë) ùëâd,ùêπd ‚Üê decimate ùëâmc,ùêπmc to ùëö faces ùëâu,ùêπu ‚Üê self-union ùëâd,ùêπd via [Zhou et al. 2016] ùëât,ùëát, ùêπt ‚Üê tetrahedralize ùëâu,ùêπu via [Si 2015] if any step failed or ùëât,ùêπt does not strictly contain ùëâin,ùêπin
then increase ùëë
else decrease ùëë
return ùëât,ùëát

Raw per-tet fracture

Post-processed

Fig. 11. We use the upper envelope extraction algorithm by Abdrashitov et al. [2021] to obtain smoothed fracture faults.

[Zhou et al. 2016] triangle mesh of a fracture fragment. Since the impact projection described above is linear, we can pre-restrict the projection to vertices on the boundary of these fragments, discarding all internal vertices and the tetrahedral connectivity.

3.5 Simple Nested Cages

In practice, the input model may be very high-resolution, not yet fully modeled when fractures are precomputed, or too messy to easily tetrahedralize. Like many simulation methods before us, we can avoid these potential performance, workflow and robustness problems by working with a tetrahedral coarse cage nesting the input. The Nested Cages method of Sacht et al. [2015] produces tight fitting cages, but suffers long runtimes, potential failure, and may result in a surface mesh which causes subsequent tetrahedralization (e.g., using TetWild [Hu et al. 2018] or TetGen [Si 2015]) to fail.

Therefore, in Algorithm 2 we introduce a Input very simple caging method inspired by the

Cage

level-set method of Ben-Chen et al. [2009].

As an example, Nested Cages crashes after

a minute on the input mesh in the inset, while

our simple algorithm produces a satisfying out-

put cage after 85 seconds.

Like Nested Cages, the output cage will

strictly contain the input, but also by construction we ensure that

this cage can be successfully tetrahedralized (not just in theory).

In a sense, this method provides a different point on the Pareto

frontier of tightness-vs-utility. Each step is a fairly standard geome-

try processing subroutine with predictable performance, and one

may even consider using it as an initialization strategy for Nested

Cages to improve tightness in the future. We run a max of 10 search

iterations, lasting between 5 and 20 seconds each in our examples.

Table 1. Performance details for all our examples

Fig. #T Time/mode (s) ùëò ùëù Impact Proj. (ms)

7 6316

2.86

30 47

1.06

18 3931

2.20

20 117

1.21

14 (a) 3545

0.63

10 35

1.13

14 (b) 4993

2.63

25 34

1.08

16 12162

11.6

10 31

1.19

19 8802

5.91

15 152

1.96

Fracture modes and solid fragment components on the cage‚Äôs tetrahedralization can be transferred to the true input geometry by intersecting each connected component against the input mesh. In this way, the exterior surface of each fragment component is exactly a subset of the input mesh.

3.6 Smoothing internal surfaces

By our construction, the fracture boundaries will follow faces of

the tetrahedral mesh used for their computation. This reveals alias-

ing with frequency proportional to the mesh resolution. We may

optionally alleviate this by treating each extracted per-tet com-

ponent membership as a one-hot vector field, which we immedi-

ately average onto (unexploded) mesh vertices stored as a matrix Z ‚àà [0, 1]ùëõ√ó|components|, so that Zùëñ,ùëó ‚àà [0, 1] is viewed as the like-
lihood that vertex ùëñ belongs to component ùëó. We apply implicit

Laplacian smoothing with a time step of ùúÜ to columns of Z:

Z ‚Üê (M + ùúÜL)‚àí1 (MZ),

(24)

where M, L, are the mass and Laplacian matrices, respectively. The resulting Z continue to contain fractional values in [0, 1] corresponding to a smoothed likelihood. We now re-extract piecewiselinear (triangle mesh) component boundaries by computing the upper-envelope (tracking the argmax) using the implementation of Abdrashitov et al. [2021]. While essentially still using the same tetrahedral mesh, utilizing smoothing and piecewise-linear interpolation greatly reduces aliasing artifacts (see Fig. 11).
By the nature of the Laplacian, Eq. (24) will push our fracture faults towards smooth surfaces. This is in alignment with our modeling decisions at the beginning of Section 3: as our set of possible fault patches ùëÜùëñ becomes larger, the area integral in Eq. (5) will encourage smoother fracture fault surfaces. Thus, the postprocessing described here is not a departure from our model; rather, a way of alleviating the error introduced by the mesh discretization.
In the real world, crystalline materials do break along smooth surfaces aligned with their internal structure in a phenomenon known as cleavage (see e.g., [Ford and Dana 1922] Part II.I.277). On the other hand, materials like wood or clay do not necessarily break along smooth faults like those produced by our method. This is a well-studied limitation we share with all mesh-based fracture algorithms and which could be alleviated by borrowing strategies from the literature like the Adaptive Fracture Refinement by Chen et al. [2014], perturbation of crack surface vertices as described by Fan et al. [2022], or the use of pre-authored ‚Äúsplinters‚Äù suggested by Parker and O‚ÄôBrien [2009].

Breaking Good: Fracture Modes for Realtime Destruction ‚Ä¢ 1:7

100 ED
10-2 10-4

Energy of Ô¨Årst (non-trivial) fracture mode

Fracture without elastic deformation

Elastic deformation without fracture

ES 10-2
10-4 10-8

10-6

10-12

10-8 10-5

œâ grows

10-16 10+5

Fig. 12. As our energy weight changes, our output modes sharply transition from only deforming to only fracturing. This gives us the additional insight that fractures occur only within the nullspace of the strain energy, and has the additional effect of making ùúî a simple parameter to set.

3.7 Choice of strain energy

So far the only requirement on the strain energy density Œ® is that we can construct its second-order approximation near the rest configuration represented by the (positive semi-definite) Hessian matrix Q. We now investigate the effect of choices of Q and in particular the relationship with the balancing weight ùúî.
To make our investigation concrete, take Œ® to be the linear elastic strain energy density, so that Q is the common linear elasticity stiffness matrix. Our observations also follow if one chooses Q to be the Hessian of other, nonlinear energies like the Neohookean or St. Venant-Kirchhoff ones. By sweeping across values of ùúî we see a sharp change in the first (and all) fracture mode‚Äôs behavior with the discontinuity energy dominating over the strain energy and then sharply swapping (see Fig. 12). When the discontinuity energy is effectively zero, then we have simply recovered the usual linear elastic vibration modes (albeit in a convoluted way).

When the strain energy is effectively

Energy

zero, then we not only start to see 100

ED

sparse fractures, but we also see that 10-4 each fracture fragment undergoes its

ES

own zero-strain energy transformation. 10-8
1
This behaviour is consistent even in

Mode

100

larger order modes (inset). That is, each fragment undergoes a lin-

earized rigid transformation, the only motions in the null space of

the strain energy. Physically, this behaviour naturally aligns our

fracture modes with the traditional definition of stiff brittle fracture,

where materials do not significantly deform before breaking. This

is also interesting from a numerical perspective as it implies that

the precise choice Q is irrelevant and only its null space matters.

With this in mind, we consider whether all linearized rigid trans-

formations should be admissible. Since we ultimately care about the

fracture pattern created by the modes, we observed qualitatively

that the scaling induced by linearized rotations resulted in small

elements breaking off and expanding between fragment boundaries

to reduce the discontinuity energy. Rather than attempt to iden-

tify these as outliers, we found a simpler solution is to work with a

strain energy that only admits translational motions in its null space, namely, Œ®(ùë¢, ùë•) = ‚à•‚àáùë¢ (ùë•) ‚à•2. The Hessian of ‚à•‚àáùë¢ (ùë•) ‚à•2 is simply the cotangent Laplacian matrix LÀú ‚àà R(ùëë+1)ùëö√ó(ùëë+1)ùëö repeated for

each spatial coordinate:

Q = Iùëë ‚äó LÀú .

(25)

This choice of Q is used in all our examples.

ACM Trans. Graph., Vol. 1, No. 1, Article 1. Publication date: January 2022.

1:8 ‚Ä¢ Silvia Sell√°n, Jack Luong, Leticia Mattos Da Silva, Aravind Ramakrishnan, Yuchuan Yang, and Alec Jacobson

Input

Our impact-dependent projected fracture Back-Ô¨Årst

2m15s

Face-Ô¨Årst

Fig. 14. Similar impacts result in different fracture patterns once we have computed our fracture modes for different objects.

Our fracture modes

Feet-Ô¨Årst

Most common femur fracture

Random Voronoi fractures Our 1st fracture mode

Fig. 15. A healthy femur will usually break at the mid-shaft (see e.g., [Adnan

et al. 2012]), as our first fracture mode correctly identifies, unlike Voronoi-

based algorithms. Left image by Servier Medical Art under CC BY-SA 3.0.

Fig. 13. Our precomputed fracture modes identify the geometrically weakest regions of a shape, and are activated or not on runtime depending on the nature of the impact.
Efficient precomputation. Our observation regarding the nullspace of Q can be further exploited to greatly reduce the cost of our offline mode precomputation step. Our strain energy being numerically zero in all our modes means all (exploded) vertices belonging to a single element undergo identical deformations. Therefore, by transforming this observation into an assumption, we may store deformations solely at elements, reducing our number of variables by a factor of ùëë + 1. This ensures that the strain energy measure on the exploded mesh will always be null, which also means we can remove the quadratic term u‚ä§Qu from Eq. (16). Further, allowing only per-element deformations also makes our vector discontinuity ùê∑ necessarily constant along element boundaries, which makes its integral in Eq. (13) trivial without the need of quadrature nodes. The combination of all these observations significantly reduce the size of our conic problem (see Appendix B), allowing computation of identical fracture modes several orders of magnitude faster.
4 TIMING & IMPLEMENTATION DETAILS
We have implemented our main prototype in Python, using Libigl [Jacobson et al. 2018]. We used Mosek [ApS 2019] to solve the conic problem in Eq. (16). We report timings conducted on a 2020 13-inch MacBook Pro with 16 GB memory and 2.3 GHz Quad-Core Intel Core i7 processor. To produce our animations, we follow a traditional Houdini [SideFX 2020] fracture simulation workflow, exchanging the usual Voronoi or openVDB fracture nodes for our own fractured meshes. Our impact projection step could be fully
ACM Trans. Graph., Vol. 1, No. 1, Article 1. Publication date: January 2022.

integrated into Houdini‚Äôs rigid body simulator at a minimal performance cost. Only for simplicity in prototyping, we chose not to do this and instead compute our final mesh Œ©‚òÖ in Python taking into account the animation‚Äôs impact and load it into Houdini directly to show a prototype of what our algorithm would look like integrated in a rigid body simulation.
Our algorithm‚Äôs only parameters are the tolerances ùúÄ and ùúé, which we fix at ùúÄ = 10‚àí10 and ùúé = 10‚àí3. As we discuss in Section 3.7, a scalar ùúî will not actually have an effect in the output as long as it is small enough for us to be within the zero-deformation fracture realm (see Fig. 12).
Our proposed algorithm works in two steps. First, we precompute a given shape‚Äôs fracture modes. This step takes place offline, following Algorithm 1. The computational bottleneck of this section of our algorithm is the conic solve detailed in Eq. (16). Each mode takes between 0.5 and 12 seconds to compute in our meshes, which have between 3,000 and 15,000 tetrahedra.
Secondly, our impact projection step as detailed in Section 3.3 is the only part of our algorithm that happens at runtime. The complexity of this step is dominated by the projection step in Eq. (20), which is O (ùëòùëõÀú), where ùëò is the number of precomputed modes and ùëõÀú is the number of vertices in the boundary of the connected components described in Section 3.4. All other elements of our projection step are O (ùëù), where ùëù is the number of connected components (in our example between 10 and 500) and ùëù << ùëõ so they can be disregarded from the complexity discussion. In our examples, ùëõÀú is between 1,000 and 10,000 and we compute between ùëò = 20 and ùëò = 40 fracture modes, meaning our full runtime step requires between 0.1 and 1 million floating point operations, putting it well within realtime requirements, even if one greatly increases ùëõÀú, ùëò or the number of objects on scene (note this projection step only needs to be run when a collision is detected, and not at every simulation frame). Our unoptimized, CPU implementation takes between one and two miliseconds to carry out this step on our laptop (see Table 1).

Breaking Good: Fracture Modes for Realtime Destruction ‚Ä¢ 1:9
3m15s

Input

First fracture mode‚Ä¶

Fig. 16. Ouch, my head hurts! Output

Painted Œ∑

‚Ä¶with isotropic Œ∑ ‚Ä¶with anisotropic Œ∑ Fig. 17. We can simulate the natural breaking tendencies of anisotropic materials like wood through weights in our vector valued discontinuity.

Œ∑>>
Œ∑<<
Input

2m46s Our fracture modes

5 EXPERIMENTS & COMPARISONS
Our proposed fracture modes naturally identify the regions of a shape that are geometrically weak, as opposed to existing procedural prefracture algorithms. We make this explicitly clear in Figs. 3 and 15, where existing prefracture work fails to identify even the most obvious intuitive breaking patterns which are present in our first (non-trivial) fracture mode. Even in less didactic examples, Voronoibased prefracture methods result in convex, unrealistic and easily recognizable pieces (see Figs. 22 and 2), while our fracture modes are realistic and can produce a much wider set of shapes.
‚ÄúRealism‚Äù in a fracture simulation is a hard quantity to evaluate; however, there exist works on structural analysis like [Zhou et al. 2013] that idenfity the weakest regions of a given object. In Fig. 5, we show how our fracture modes produce breaking patterns that align both with their analysis as well as with their real-life experiments.
We model heterogeneous and anisotropic materials by incorporating a vector field ùúÇ : Œ© ‚Üí Rùëë to the discontinuity energy:

ùëù‚à´

ùê∏ùê∑ (ùë¢) =

‚à•ùúÇ (ùë•) ‚ó¶ ùê∑ (ùë¢, ùë•) ‚à•2ùëëùë• ,

(26)

ùëñ=1 ùëÜùëñ

where ‚ó¶ denotes Hadamard (elementwise) multiplication. In Fig. 18, we experiment with varying the magnitude of ùúÇ as an artist control tool to designate regions that should not fracture. In Fig. 17, we make ùúÇ = (10, 10, 1) to favour vertical faults over horizontal ones.

5.1 Fracture simulations
Our proposed method is ideal for use in interactive applications. In Fig. 4, we show screenshots of our 2D realtime fracture interactive app. The user can cause different impacts on the object and see the fracture patterns that result from projecting them onto our modes.
The interactive Computer Graphics application par excellence is video games. In Fig. 7, we show a prototype where our precomputed fracture modes for a Space Wizard Vehicle can be stored so that

Fig. 18. The magnitude of our ùúÇ parameter can be painted into our input to
signal areas that shouldn‚Äôt fracture; e.g., in objects with different materials.
the player sees different fracture behaviours depending on the received impact. In Fig. 14, we precompute the fracture modes for two different vehicles and show how they break under a similar impact.
Our algorithm can be used for any realtime fracture application, from simple objects breaking into solid pieces in the foreground of an animation (see Fig. 13) to thin shells shattering upon impact (see Figs. 19 and 18). In Fig. 16, we use our fracture modes to simulate a human skull breaking into many pieces upon impact with a wall.
6 LIMITATIONS & FUTURE WORK
Our fracture modes method is intended for stiff brittle fracture. We conjecture that general rigid fracture and even ductile fracture simulation could also benefit from our sparse-norm formulation. In future work, we would like to improve the performance of our precomputation optimization. We experimented with Manopt [Boumal et al. 2014], but so far observed significantly slower performance than our proposed method. For very large meshes, the projection step could exceed CPU usage allowances for realtime applications. It may be possible to conduct this entirely on the GPU.
Our fracture modes are global in nature, meaning they create relations between regions of the object that will not typically fracture together (unlike other prefracture methods like [Oh et al. 2012]). A way of preventing a fracture in one location from also causing an undesired fracture elsewhere is to use our modes only to identify the pieces that could break off of an object in the precomputation step, and swap our realtime impact projection for a least squares constant-per-piece approximation (see Fig. 21).
Our use of an exploded mesh Œ©Àú allows us to expand the usual finite element hat function basis to include discontinuities along element boundaries. This mesh dependency is not present in traditional Voronoi or plane-cutting prefracture algorithms, and can
ACM Trans. Graph., Vol. 1, No. 1, Article 1. Publication date: January 2022.

1:10 ‚Ä¢ Silvia Sell√°n, Jack Luong, Leticia Mattos Da Silva, Aravind Ramakrishnan, Yuchuan Yang, and Alec Jacobson

3m36s

Fig. 19. A glass cup shatters, resulting in many non-convex pieces that would be impossible to obtain with Voronoi-based prefracture methods.

Input

Our output fracture with diÔ¨Äerent impacts

Fig. 20. If a given fracture mode is contained in our fracture modes, it can occur under any directional impact, as shown in this simple example inspired by O‚ÄôBrien and Hodgins [1999].

Input Fracture modes

Impact

Projection Best per-piece to modes approximation

Fig. 21. Our modes‚Äô global nature (left) means some regions can be artifi-

cially linked (right middle). We could solve this by exchanging our mode pro-

jection for the least-squares best constant-per-piece approximation (right)

lead to visible artifacts if the simulation mesh is too coarse. We alleviate it with post-facto smoothing (Section 3.6). Another way of reducing it (at a performance cost) would have been to include basis functions with sub-mesh-resolution discontinuities in the style of XFEM [Chitalu et al. 2020; Kaufmann et al. 2009].
Our algorithm is designed to fit into realtime rigid body simulations like those encountered in video games. Thus, our outputs will not contain partial fractures (unlike e.g., [M√ºller et al. 2013]).

Secondary fractures were not included in our

simulations. Computing a new set of fracture

modes for each piece would exceed realtime

constraints. While one could obtain plausible

secondary fractures by restricting our precomputed fracture modes and pattern to each pri-

2nd fractures

mary fracture piece (see inset), there is no guarantee that these

would match the individual piece‚Äôs fracture modes.

We use a vector field ùúÇ to model an object‚Äôs preferred breaking

behaviour (see Figs. 18 and 17). Promising future work includes

incorporating physical material properties into our mode computa-

tion; for example, by treating tangential and normal discontinuities

differently.

Our method belongs to the class of prefracture, not dynamic

algorithms. Nonetheless, our method can be evaluated on dynamic

fracture benchmarks like the notched block in [O‚ÄôBrien and Hodgins

1999]: if a given fracture plane is contained in one of our fracture

modes, it can be present in the fractured output (see Fig. 20). The

fracture fault will be the same regardless of the directionality of the

impact. This deviates from the real-world mechanical behaviour,

where faults will be different for brittle materials under uniaxial

tension, pure shear, and torsion loads (see [Lawn 1993], Chap. 2).

We hope our introduction of fracture eigenmodes inspires the

realtime simulation community further to use the well-studied tools

of modal analysis to this rich problem, and the broader Computer

Graphics research community to look at other open problems with

this modal lens.

ACM Trans. Graph., Vol. 1, No. 1, Article 1. Publication date: January 2022.

Input

Voronoi prefracture

Our prefracture

Fig. 22. The pieces generated by Voronoi-based methods can be extremely unrealistic (center). By combining all the possible fractures in all our modes into a single prefractured mesh, we can provide a zero-extra-realtime-cost alternative to procedural algorithms.

ACKNOWLEDGMENTS
This project is funded in part by NSERC Discovery (RGPIN2017‚Äì05235, RGPAS‚Äì2017‚Äì507938), New Frontiers of Research Fund (NFRFE‚Äì201), the Ontario Early Research Award program, the Canada Research Chairs Program, the Fields Centre for Quantitative Analysis and Modelling and gifts by Adobe. The first author is supported by an NSERC Vanier Scholarship and an Adobe Fellowship. The four middle authors were supported by the 2020 Fields Undergraduate Summer Research Program.
We acknowledge the authors of the 3D models used throughout this paper: MakerBot (Fig. 1, CC BY 4.0), HQ3DMOD (Figs. 6 and 19, TurboSquid 3D Standard Model License), Freme Minskib (Fig. 7, CC BY-NC 4.0), 3Demon (Fig. 9, CC BY-NC-SA 4.0), Reality_3D (Fig. 11, CC BY 4.0), Alex (Fig. 14, CC BY-NC-SA 4.0), Falha Tecnologica (Fig. 18, TurboSquid 3D Standard Model License), LeFabShop (Fig. 16, CC BY-NC 4.0), The Database Center for Life Science (Fig. 15, CC BY-SA 2.1) and Gijs (inset in Section 3.5, CC BY-NC 4.0).
We are grateful to the anonymous peer reviewers for their insightful suggestions. We would especially like to thank Reviewer #3 for inspiring the shockwave-based impact projection in Section 3.3.
We would also like to thank Chris Wojtan, David Hahn and Klint Qinami for early experiments and discussions of sparse-norm fracture models; Eitan Grinspun, David I.W. Levin, Oded Stein and Jackson Phillips for insightful conversations; Rinat Abdrashitov for providing an implementation of his algorithm mentioned in Section 3.6; Qingnan Zhou for providing the 3D models used in Fig. 5; Xuan Dam, John Hancock and all the University of Toronto DCS staff that kept our lab running during the hardest of times.

Breaking Good: Fracture Modes for Realtime Destruction ‚Ä¢ 1:11

REFERENCES
Rinat Abdrashitov, Seungbae Bang, David IW Levin, Karan Singh, and Alec Jacobson. 2021. Interactive Modelling of Volumetric Musculoskeletal Anatomy. ACM Transactions on Graphics 40, 4 (2021).
Rana Muhammad Adnan, Muhammad Irfan Zia, Jahanzaib Amin, Rafya Khan, Saleem Ahmed, and Khalid F Danish. 2012. Frequency of Femoral Fractures. The Professional Medical Journal 19, 01 (2012), 011‚Äì014.
MOSEK ApS. 2019. The MOSEK optimization toolbox for MATLAB manual. Version 9.0. http://docs.mosek.com/9.0/toolbox/index.html
Zhaojun Bai, James Demmel, Jack Dongarra, Axel Ruhe, and Henk van der Vorst. 2000. Templates for the solution of algebraic eigenvalue problems: a practical guide. SIAM.
Mirela Ben-Chen, Ofir Weber, and Craig Gotsman. 2009. Spatial deformation transfer. In Proc. SCA, Dieter W. Fellner and Stephen N. Spencer (Eds.).
N. Boumal, B. Mishra, P.-A. Absil, and R. Sepulchre. 2014. Manopt, a Matlab Toolbox for Optimization on Manifolds. Journal of Machine Learning Research 15, 42 (2014), 1455‚Äì1459. https://www.manopt.org
Stephen P. Boyd. 2010. Distributed Optimization and Statistical Learning Via the Alternating Direction Method of Multipliers.
Christopher Brandt and Klaus Hildebrandt. 2017. Compressed vibration modes of elastic bodies. Computer Aided Geometric Design 52 (2017), 297‚Äì312.
Emmanuel J. Candes and Michael B. Wakin. 2008. An Introduction To Compressive Sampling.
Zhili Chen, Miaojun Yao, Renguo Feng, and Huamin Wang. 2014. Physics-inspired adaptive fracture refinement. ACM Transactions on Graphics 33, 4 (2014).
Floyd M Chitalu, Qinghai Miao, Kartic Subr, and Taku Komura. 2020. DisplacementCorrelated XFEM for Simulating Brittle Fracture. In Computer Graphics Forum, Vol. 39. Wiley Online Library, 569‚Äì583.
S Roy Chowdhury and R Narasimhan. 2000. A cohesive finite element formulation for modelling fracture and delamination in solids. Sadhana 25, 6 (2000), 561‚Äì587.
Linxu Fan, Floyd M. Chitalu, and Taku Komura. 2022. Simulating Brittle Fracture with Material Points. ACM Trans. Graph. 41, 5, Article 177 (may 2022), 20 pages. https://doi.org/10.1145/3522573
William E Ford and Edward S Dana. 1922. A Textbook of Mineralogy: With an Extended Treatise on Crystallography and Phys. Mineralogy. Wiley.
Loeiz Glondu, Maud Marchal, and Georges Dumont. 2012. Real-time simulation of brittle fracture using modal analysis. IEEE Transactions on Visualization and Computer Graphics 19, 2 (2012), 201‚Äì209.
David Hahn and Chris Wojtan. 2015. High-resolution brittle fracture simulation with boundary elements. ACM Trans. Graph. 34, 4 (2015), 151:1‚Äì151:12.
David Hahn and Chris Wojtan. 2016. Fast approximations for boundary element based brittle fracture simulation. ACM Trans. Graph. 35, 4 (2016), 104:1‚Äì104:11. https://doi.org/10.1145/2897824.2925902
Koichi Hirota, Yasuyuki Tanoue, and Toyohisa Kaneko. 1998. Generation of crack patterns with a physical model. The visual computer 3, 14 (1998), 126‚Äì137.
Yixin Hu, Qingnan Zhou, Xifeng Gao, Alec Jacobson, Denis Zorin, and Daniele Panozzo. 2018. Tetrahedral meshing in the wild. ACM Trans. Graph. (2018).
George R Irwin. 1957. Analysis of stresses and strains near the end of a crack traversing a plate. Journal of Applied Mechanics (1957).
Alec Jacobson, Daniele Panozzo, et al. 2018. libigl: A simple C++ geometry processing library. https://libigl.github.io/.
Peter Kaufmann, Sebastian Martin, Mario Botsch, Eitan Grinspun, and Markus Gross. 2009. Enrichment Textures for Detailed Cutting of Shells. ACM Trans. Graph. (2009).
Madhu S Kirugulige, Hareesh V Tippur, and Thomas S Denney. 2007. Measurement of transient deformations using digital image correlation method and high-speed photography: application to dynamic fracture. Applied optics 46, 22 (2007).
Dan Koschier, Sebastian Lipponer, and Jan Bender. 2015. Adaptive tetrahedral meshes for brittle fracture simulation. In SCA ‚Äô14.
Brian R Lawn. 1993. Fracture of brittle solids. Cambridge solid state science series (1993). R. B. Lehoucq, D. C. Sorensen, and C. Yang. 1998. ARPACK Users‚Äô Guide. Society for
Industrial and Applied Mathematics. https://doi.org/10.1137/1.9780898719628 Lien Muguercia, Carles Bosch, and Gustavo Patow. 2014. Fracture modeling in computer
graphics. Computers & graphics 45 (2014), 86‚Äì100. Matthias M√ºller, Nuttapong Chentanez, and Tae-Yong Kim. 2013. Real time dynamic
fracture with volumetric approximate convex decompositions. ACM Transactions on Graphics (TOG) 32, 4 (2013), 1‚Äì10. Matthias Muller, Matthias Teschner, and Markus Gross. 2004. Physically-based simulation of objects represented by surface meshes. In Proceedings Computer Graphics International, 2004. IEEE, 26‚Äì33. Ken Museth, Peter Cucka, Mihai Alden, and David Hill. 2021. OpenVDB. T. Neumann, K. Varanasi, C. Theobalt, M. Magnor, and M. Wacker. 2014. Compressed Manifold Modes for Mesh Processing. Computer Graphics Forum 33, 5 (2014), 35‚Äì44. Thomas Neumann, Kiran Varanasi, Stephan Wenger, Markus Wacker, Marcus A. Magnor, and Christian Theobalt. 2013. Sparse localized deformation components. ACM Trans. Graph. (2013). Alan Norton, Greg Turk, Bob Bacon, John Gerth, and Paula Sweeney. 1991. Animation of fracture by physical modeling. The visual computer 7, 4 (1991), 210‚Äì219.

James F O‚ÄôBrien and Jessica K Hodgins. 1999. Graphical modeling and animation of brittle fracture. In Proceedings of the 26th annual conference on Computer graphics and interactive techniques. 137‚Äì146.
Seungtaik Oh, Seunghyup Shin, and Hyeryeong Jun. 2012. Practical simulation of hierarchical brittle fracture. Computer Animation and Virtual Worlds 23, 3-4 (2012).
Michael Ortiz and Anna Pandolfi. 1999. Finite-deformation irreversible cohesive elements for three-dimensional crack-propagation analysis. International journal for numerical methods in engineering 44, 9 (1999), 1267‚Äì1282.
V. Ozolins, R. Lai, R. Caflisch, and S. Osher. 2013. Compressed modes for variational problems in mathematics and physics. Proceedings of the National Academy of Sciences 110, 46 (Oct 2013), 18368‚Äì18373. https://doi.org/10.1073/pnas.1318679110
Eric G Parker and James F O‚ÄôBrien. 2009. Real-time deformation and fracture in a game environment. In Proceedings of the 2009 ACM SIGGRAPH/Eurographics Symposium on Computer Animation. 165‚Äì175.
Tobias Pfaff, Rahul Narain, Juan Miguel de Joya, and James F. O‚ÄôBrien. 2014. Adaptive Tearing and Cracking of Thin Sheets. ACM Trans. Graph. (2014).
Roi Poranne, Marco Tarini, Sandro Huber, Daniele Panozzo, and Olga Sorkine-Hornung. 2017. Autocuts: simultaneous distortion and cut optimization for UV mapping. ACM Transactions on Graphics (TOG) 36, 6 (2017), 1‚Äì11.
Saty Raghavachary. 2002. Fracture generation on polygonal meshes using Voronoi polygons. In ACM SIGGRAPH 2002 conference abstracts and applications. 187‚Äì187.
Leonardo Sacht, Etienne Vouga, and Alec Jacobson. 2015. Nested cages. ACM Trans. Graph. (2015).
Sara C. Schvartzman and Miguel A. Otaduy. 2014. Fracture Animation Based on HighDimensional Voronoi Diagrams. In Proc. I3D.
Hang Si. 2015. TetGen, a Delaunay-Based Quality Tetrahedral Mesh Generator. ACM Trans. Math. Softw. (2015).
SideFX. 2020. Houdini. https://www.sidefx.com Jonathan Su, Craig Schroeder, and Ronald Fedkiw. 2009. Energy stability and fracture
for frame rate rigid body simulations. In Proceedings of the 2009 ACM SIGGRAPH/Eurographics Symposium on Computer Animation. 155‚Äì164. Martin Wicke, Daniel Ritchie, Bryan M Klingner, Sebastian Burke, Jonathan R Shewchuk, and James F O‚ÄôBrien. 2010. Dynamic local remeshing for elastoplastic simulation. ACM Transactions on graphics (TOG) 29, 4 (2010), 1‚Äì11. Joshuah Wolper, Yunuo Chen, Minchen Li, Yu Fang, Ziyin Qu, Jiecong Lu, Meggie Cheng, and Chenfanfu Jiang. 2020. AnisoMPM: Animating anisotropic damage mechanics: Supplemental document. ACM Trans. Graph 39, 4 (2020). Joshuah Wolper, Yu Fang, Minchen Li, Jiecong Lu, Ming Gao, and Chenfanfu Jiang. 2019. CD-MPM: continuum damage material point methods for dynamic fracture animation. ACM Transactions on Graphics (TOG) 38, 4 (2019), 1‚Äì15. Nafees Bin Zafar, David Stephens, M√•rten Larsson, Ryo Sakaguchi, Michael Clive, Ramprasad Sampath, Ken Museth, Dennis Blakey, Brian Gazdik, and Robby Thomas. 2010. Destroying LA for" 2012". In ACM SIGGRAPH 2010 Talks. 1‚Äì1. Qingnan Zhou, Eitan Grinspun, Denis Zorin, and Alec Jacobson. 2016. Mesh arrangements for solid geometry. ACM Trans. Graph. (2016). Qingnan Zhou, Julian Panetta, and Denis Zorin. 2013. Worst-case structural analysis. ACM Trans. Graph. 32, 4 (2013), 137‚Äì1. Yufeng Zhu, Robert Bridson, and Chen Greif. 2015. Simulating Rigid Body Fracture with Surface Meshes. ACM Trans. Graph. (2015). Yufeng Zhu, Jovan Popoviƒá, Robert Bridson, and Danny M Kaufman. 2017. Planar interpolation with extreme deformation, topology change and dynamics. ACM Transactions on Graphics (TOG) 36, 6 (2017), 1‚Äì15.

A CANONICAL CONIC PROGRAM FORM OF EQ. (16)
Let us define a sparse matrix D ‚àà Rùëùùëë√óùëë (ùëë+1)ùëö that operates on a deformation map and evaluates the vector-valued discontinuities at all the relevant integration quadrature points. The ordering of the rows of D is arbitrary, and we choose it such that D can be separated into ùëë blocks, one for each quadrature point.
For example, in the case ùëë = 2, we choose said ordering such that the first ùëù rows of Du are the vector-valued edge-wise discontinuity

ùëôùëí d

1 ‚àö

23

from Eq. (13) and the last ùëù rows of Du correspond to

ùëôùëí d

‚àí1 ‚àö

.

23

ACM Trans. Graph., Vol. 1, No. 1, Article 1. Publication date: January 2022.

1:12 ‚Ä¢ Silvia Sell√°n, Jack Luong, Leticia Mattos Da Silva, Aravind Ramakrishnan, Yuchuan Yang, and Alec Jacobson

Since Q is positive semi-definite, we can write it as Q = R‚ä§R for some matrix R. Define

Yùëí = (Du)ùëí , ‚àÄùëí = 1, . . . , 2ùëù,

(27)

where ùëôùëí is the length of edge ùëí. Next, define

rùëñ = (Ru)ùëñ , ‚àÄùëñ = 1, . . . , ùëë (ùëë + 1)ùëö.

(28)

Then, Eq. (16) can be written in the canonical form

Ô£Æ1Ô£π‚ä§ Ô£Æùë° Ô£π

Ô£ØÔ£Ø0Ô£∫Ô£∫

Ô£Ø Ô£Ø

r

Ô£∫ Ô£∫

argmin Ô£ØÔ£Ø0Ô£∫Ô£∫ Ô£ØÔ£ØuÔ£∫Ô£∫

(29)

u,ùë°,Y,z Ô£ØÔ£Ø0Ô£∫Ô£∫ Ô£ØÔ£ØYÔ£∫Ô£∫

Ô£ØÔ£∫ Ô£Ø Ô£∫ Ô£Ø1Ô£∫ Ô£ØzÔ£∫

Ô£∞Ô£ª Ô£∞ Ô£ª

subject to

ùë°‚â•

r21

+

.

.

.

+

r2
ùëë

(ùëë +1)ùëö

zùëí ‚â•

ùëë ‚àí1

Yùëí+ùë†ùëù

2 2

‚àÄùëí = 1, . . . , ùëù

ùë† =0

Y = Du

r = Ru c‚ä§ùëÄÀú u = 1

Uùëó ùëÄÀú u = 0 , ‚àÄùëó = 1, . . . , ùëñ ‚àí 1.

B EFFICIENT CONIC PROGRAM FROM SECTION 3.7
Let C be the R(ùëë+1)ùëö√óùëö matrix of ones and zeros that transfers values from elements to vertices in the exploded mesh, and let us assume now that we are storing per-element deformations in vectors v, Uùëó , c ‚àà Rùëëùëö. Then, our conic problem from Appendix A becomes

Ô£Æ1Ô£π‚ä§ Ô£Æùë° Ô£π

Ô£ØÔ£Ø0Ô£∫Ô£∫

Ô£Ø Ô£Ø

r

Ô£∫ Ô£∫

argmin Ô£ØÔ£Ø0Ô£∫Ô£∫ Ô£ØÔ£ØvÔ£∫Ô£∫

(30)

v,ùë° ,Y,z

Ô£ØÔ£∫ Ô£Ø0Ô£∫

Ô£ØÔ£∫ Ô£ØYÔ£∫

Ô£ØÔ£∫ Ô£Ø Ô£∫ Ô£Ø1Ô£∫ Ô£ØzÔ£∫

Ô£∞Ô£ª Ô£∞ Ô£ª

subject to

ùë°‚â•

r21

+

.

.

.

+

r2
ùëë

(ùëë +1)ùëö

zùëí ‚â•

ùëë ‚àí1

Yùëí+ùë†ùëù

2 2

‚àÄùëí = 1, . . . , ùëù

ùë† =0

Y = DCv

r = RCv

c‚ä§ùëÄÀú u = 1

Uùëó ùëÄÀú u = 0 , ‚àÄùëó = 1, . . . , ùëñ ‚àí 1.

By construction, QCv = 0 ‚áí RCv = 0, which means we can remove ùë° and r as variables entirely. Further, since the vector-valued discontinuity is constant across element boundaries, Yùëí = Yùëí+ùë†ùëù , with ùë† = 0, . . . , ùëë ‚àí 1, meaning that we can remove the summation

from the ùëßùëí cone and consider only the first ùëù rows of Y. This leads to the equivalent, simpler conic program

Ô£Æ0Ô£π‚ä§ Ô£ÆvÔ£π

argmin Ô£ØÔ£Ø0Ô£∫Ô£∫ Ô£ØÔ£ØYÔ£∫Ô£∫

(31)

v,Y

Ô£ØÔ£∫ Ô£Ø1Ô£∫

Ô£ØÔ£∫ Ô£ØzÔ£∫

Ô£∞Ô£ª Ô£∞ Ô£ª

subject to

zùëí ‚â• ùëë ‚à•Yùëí ‚à•22 ‚àÄùëí = 1, . . . , ùëù (Y)ùëí = (DCv)ùëí ‚àÄùëí = 1, . . . , ùëù
c‚ä§C‚ä§MCv = 1 Uùëó C‚ä§MCv = 0 , ‚àÄùëó = 1, . . . , ùëñ ‚àí 1.

ACM Trans. Graph., Vol. 1, No. 1, Article 1. Publication date: January 2022.

